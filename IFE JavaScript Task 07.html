<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>IFE JavaScript Task 07</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		div {
			margin: 20px 20px 20px 20px;
			border: 1px solid;
			overflow: hidden;
		}

		section {
			overflow: hidden;
		}

		section div {
			float: left;
			background-color: #fff;
		}

		section > div {
			width: 500px;
			z-index: 2;
		}

		section > div > div {
			z-index: 3;
		}
		
		section > div > div > div{
			z-index: 4;
		}

		section > div > div > div > div {
			width: 50px;
			height: 30px;
			z-index: 5;
		}

		.buttonBox {
			display: block;
			margin: 0 50px 0 50px;
		}

	</style>
</head>
<body>
	<section>
		<div>
			<div>
				<div>
					<div></div>
					<div></div>
				</div>
				<div>
					<div></div>
					<div></div>
				</div>
			</div>
			<div>
				<div>
					<div></div>
					<div></div>
				</div>
				<div>
					<div></div>
					<div></div>
				</div>
			</div>
		</div>
		<div>
			<div>
				<div>
					<div></div>
					<div></div>
				</div>
				<div>
					<div></div>
					<div></div>
				</div>
			</div>
			<div>
				<div>
					<div></div>
					<div></div>
				</div>
				<div>
					<div></div>
					<div></div>
				</div>
			</div>
		</div>
	</section>
	<span class="buttonBox">
		<button id="prePrderTraverse">前序遍历</button>
		<button id="inOrderTraverse">中序遍历</button>
		<button id="postOrderTraverse">后续遍历</button>
	</span>
</body>
<script>
	/**
	 * 参考示例图，在页面中展现一颗二叉树的结构
	 * 提供一个按钮，显示开始遍历，点击后，以动画的形式呈现遍历的过程
	 * 二叉树的遍历算法和方式自定，前序中序后序皆可，但推荐可以提供多种算法的展示（增加多个按钮，每个按钮对应不同的算法）
	 * 当前被遍历到的节点做一个特殊显示（比如不同的颜色）
	 * 每隔一段时间（500ms，1s 等时间自定）再遍历下一个节点
	 */
	
	let tree = document.querySelector('section')
	let arr
	//按钮
	document.querySelector('#prePrderTraverse').onclick = function() {
		arr = []
		prePrderTraverse(tree)
		toggleTree()
	}
	document.querySelector('#inOrderTraverse').onclick = function() {
		arr = []
		inOrderTraverse(tree)
		toggleTree()
	}
	document.querySelector('#postOrderTraverse').onclick = function() {
		arr = []
		postOrderTraverse(tree)
		toggleTree()
	}
	//先序遍历子树
	function prePrderTraverse(tree) {
		arr.push(tree)
		if (tree.children[0]) {
			prePrderTraverse(tree.children[0])
		}
		if (tree.children[1]) {
			prePrderTraverse(tree.children[1])
		}
	}
	//中序遍历子树
	function inOrderTraverse(tree) {
		if (tree.children[0]) {
			inOrderTraverse(tree.children[0])
		}
		arr.push(tree)
		if (tree.children[1]) {
			inOrderTraverse(tree.children[1])
		}
	}
	//后续遍历子树
	function postOrderTraverse(tree) {
		if (tree.children[0]) {
			postOrderTraverse(tree.children[0])
		}
		if (tree.children[1]) {
		postOrderTraverse(tree.children[1])
		}
		arr.push(tree)
	}
	//动画部分
	function toggleTree() {
		for (let i = 0; i < arr.length + 1; i++) {
			(function(i){
				setTimeout(function(){
					if (i < arr.length + 1) {
			 			if (arr[i]) {
			 				arr[i].style.background="#cfc";			 				
			 			}
			 			if (arr[i - 1]) {
			 				arr[i - 1].style.background="#fff";			 				
			 			}
			 		}
			 	}, i * 500)
			})(i)
		}
	}

</script>
</html>
